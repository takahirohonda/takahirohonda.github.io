"use strict";(self.webpackChunkmydatahack_blog_site=self.webpackChunkmydatahack_blog_site||[]).push([[818],{39905:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=t(74848),i=t(28453);const s={sidebar_position:44},o="Refactoring React ES6 Class Components with Property Initialisers",r={id:"Web/Frontend/property-initialiser-react-class",title:"Refactoring React ES6 Class Components with Property Initialisers",description:"\u201cProprty initialisers\u201d is an experimental ES6 JavaScript feature that allows you to write React class components without constructor and bind this. It creates cleaner React class component. The use of this syntax is so wide-spread and calling it experimental (because it is not yet ratified) feels almost misleading.",source:"@site/docs/Web/Frontend/44.property-initialiser-react-class.md",sourceDirName:"Web/Frontend",slug:"/Web/Frontend/property-initialiser-react-class",permalink:"/mydatahack-old-blog/mydatahack-old-blog/Web/Frontend/property-initialiser-react-class",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:44,frontMatter:{sidebar_position:44},sidebar:"tutorialSidebar",previous:{title:"Setting up Unit Tests for React with Mocha, JSDOM and Enzyme",permalink:"/mydatahack-old-blog/mydatahack-old-blog/Web/Frontend/mocha-jsdom-enzyme-react"},next:{title:"Clarifying Which Babel to Use for Compiling React Today",permalink:"/mydatahack-old-blog/mydatahack-old-blog/Web/Frontend/babel-react"}},l={},c=[];function d(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"refactoring-react-es6-class-components-with-property-initialisers",children:"Refactoring React ES6 Class Components with Property Initialisers"}),"\n",(0,a.jsx)(n.p,{children:"\u201cProprty initialisers\u201d is an experimental ES6 JavaScript feature that allows you to write React class components without constructor and bind this. It creates cleaner React class component. The use of this syntax is so wide-spread and calling it experimental (because it is not yet ratified) feels almost misleading."}),"\n",(0,a.jsx)(n.p,{children:"Before getting into refactoring, we first need to add the babel plugin called @babel/plugin-proposal-class-properties so that babel can compile react. Without this plugin, babel will complain about arrow functions inside the class component. You can check out this pos for more reference (Clarifying which babel to use for compiling React today)."}),"\n",(0,a.jsx)(n.p,{children:"Example Classic Class Component"}),"\n",(0,a.jsx)(n.p,{children:"Here is the classic class component. For the demo purpose, it has local state that captures id value as well as dispatchers that are mapped to props."}),"\n",(0,a.jsx)(n.p,{children:"The first thing you do is to create a constructor and pass props to super. Then, create functions and bind them to this. This is necessary because of the (almost pathological) nature of JS global scoping. Without binding to this, these functions do not exist in the global this object."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'class Form extends ReactComponents {\n  constructor(props) {\n    super(props);\n    this.state = { id: "" };\n    this.submitHandler = this.submitHandler.bind(this);\n    this.nameInputHandler = this.nameInputHandler.bind(this);\n    this.idInputHandler = this.idInputHandler.bind(this);\n  }\n\n  submitHandler() {\n    // do more things here ....\n    // then dispatch action\n    this.props.onSubmitHandler();\n  }\n\n  nameInputHandler(e) {\n    // to dispatch action (redux)\n    this.props.onNameChangeHandler(e.target.value);\n  }\n\n  idInputHandler(e) {\n    // update local state\n    this.setState({ id: e.target.value });\n  }\n\n  render() {\n    return (\n      <form>\n        <label for="firstname">First name</label>\n        <input\n          type="text"\n          name="firstname"\n          id="firstname"\n          onChange={(e) => inputHandler(e)}\n        />\n        <label for="id">Id</label>\n        <input\n          type="text"\n          name="firstname"\n          id="firstname"\n          onChange={(e) => inputHandler(e)}\n        />\n        <button type="submit" onSubmit={() => this.submitHandler()}>\n          Submit\n        </button>\n      </form>\n    );\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Refectored Class Component with Property Initialisers"}),"\n",(0,a.jsx)(n.p,{children:"When we use the property initialiser feature, we can get rid of constructor. Props are accessed by this.props. The local state can be defined as a class property. Functions can be arrow function, which means you can take a full advantage of lexical scoping. Hence, you do not need to bind them to this. In the render method, you do not need to call it with arrow function."}),"\n",(0,a.jsx)(n.p,{children:"This feels cleaner, doesn\u2019t it?"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'class Form extends ReactComponents {\n  state = { id: "" };\n\n  submitHandler = () => {\n    // do more things here ....\n    // then dispatch action\n    this.props.onSubmitHandler();\n  };\n\n  nameInputHandler = (e) => {\n    // to dispatch action (redux)\n    this.props.onNameChangeHandler(e.target.value);\n  };\n\n  idInputHandler = (e) => {\n    // update local state\n    this.setState({ id: e.target.value });\n  };\n\n  render() {\n    return (\n      <form>\n        <label for="firstname">First name</label>\n        <input\n          type="text"\n          name="firstname"\n          id="firstname"\n          onChange={this.nameInputHandler}\n        />\n        <label for="id">Id</label>\n        <input\n          type="text"\n          name="firstname"\n          id="firstname"\n          onChange={this.idInputHandler}\n        />\n        <button type="submit" onSubmit={this.submitHandler}>\n          Submit\n        </button>\n      </form>\n    );\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Before wrapping it up, there is one more thing you may be interested in\u2026."}),"\n",(0,a.jsx)(n.p,{children:"Refectored Class Component to Functional Component"}),"\n",(0,a.jsx)(n.p,{children:"Not exactly the same as the original class component, but you can entirely scrap the class component and make it to a functional component. Now, the onInputHandler dispatches action connected to props. It takes name and value and keep updating the global store. onSubmitHandler is the same. It dispatches action."}),"\n",(0,a.jsx)(n.p,{children:"There is a catch. The general consensus of the community is that we should not put the form state in Redux. It is wasteful to dispatch action on every key stroke. Makes sense. It is actually in the Redux official documentation here. So, this is the anti-pattern that keep form input state in the global redux store unless you have a good use case that requires other changes depending on it."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'const Form = ({ state, onInputHandler, onSubmitHandler }) => {\n  return (\n    <form>\n      <label for="firstname">First name</label>\n      <input\n        type="text"\n        name="firstname"\n        id="firstname"\n        onChange={(e) => onInputHandler(e.target.name, e.target.value)}\n      />\n      <label for="id">Id</label>\n      <input\n        type="text"\n        name="firstname"\n        id="firstname"\n        onChange={this.idInputHandler}\n      />\n      <button type="submit" onSubmit={() => onSubmitHandler()}>\n        {state.submitButtonTitle}\n      </button>\n    </form>\n  );\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"(2019-07-06)"})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var a=t(96540);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);
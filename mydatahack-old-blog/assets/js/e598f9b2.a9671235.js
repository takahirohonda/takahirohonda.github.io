"use strict";(self.webpackChunkmydatahack_blog_site=self.webpackChunkmydatahack_blog_site||[]).push([[7385],{84707:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=n(74848),o=n(28453);const r={sidebar_position:4},s="TypeORM vs Prisma to build GraphQL APIs with TypeScript",i={id:"Web/Node.js/typeORM-prisma-graphql",title:"TypeORM vs Prisma to build GraphQL APIs with TypeScript",description:"If you are building GraphQL APIs with TypeScript and have a relational database, there are two main ORM libraries we can use: Prisma and TypeORM. Both of them are similar. They both use models to define database tables, have query APIs, handle db connection well, have good documentations and community support so on. However, if you want to know which one to use, I recommend TypeORM for the reasons below.",source:"@site/docs/Web/Node.js/4.typeORM-prisma-graphql.md",sourceDirName:"Web/Node.js",slug:"/Web/Node.js/typeORM-prisma-graphql",permalink:"/mydatahack-old-blog/docs/Web/Node.js/typeORM-prisma-graphql",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"How to Avoid Async Try-Catch Hell",permalink:"/mydatahack-old-blog/docs/Web/Node.js/async-try-catch-hell"},next:{title:"Handling Authorisation With Apollo",permalink:"/mydatahack-old-blog/docs/Web/Node.js/auth-with-apollo-server"}},d={},l=[{value:"Examples Projects",id:"examples-projects",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"typeorm-vs-prisma-to-build-graphql-apis-with-typescript",children:"TypeORM vs Prisma to build GraphQL APIs with TypeScript"}),"\n",(0,a.jsxs)(t.p,{children:["If you are building GraphQL APIs with TypeScript and have a relational database, there are two main ORM libraries we can use: Prisma and ",(0,a.jsx)(t.a,{href:"https://typeorm.io/",children:"TypeORM"}),". Both of them are similar. They both use models to define database tables, have query APIs, handle db connection well, have good documentations and community support so on. However, if you want to know which one to use, I recommend ",(0,a.jsx)(t.code,{children:"TypeORM"})," for the reasons below."]}),"\n",(0,a.jsx)(t.p,{children:"(1) Better integration with type-graphql"}),"\n",(0,a.jsxs)(t.p,{children:["This is probably the biggest point I want to make. If you want to pick and choose which database fields to expose, you need to write two different models (the one defines table and another one to define graphql schema) with ",(0,a.jsx)(t.code,{children:"Prisma"}),". This is because ",(0,a.jsx)(t.code,{children:"Prisma"})," uses its own ",(0,a.jsx)(t.code,{children:"prisma.schema"})," file to define the model."]}),"\n",(0,a.jsx)(t.p,{children:"Tables are defined in the prisma.schema file."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-graphql",children:"model book {\n  id       Int    @id @default(autoincrement())\n  title    String\n  field    String\n  authorId Int\n  author   author @relation(fields: [authorId], references: [id])\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If we are going to expose the same field as database we can just use ",(0,a.jsx)(t.code,{children:"typegraphql-prisma"})," to generate the schema from the model in ",(0,a.jsx)(t.code,{children:"prisma.schema "})," file. However, if we want to customise which fields to expose or expose a calculated field, we need to create a separate model with type-graphql decorators."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-graphql",children:"@ObjectType()\nexport class Book {\n  @Field()\n  id: number\n\n  @Field()\n  title: string\n\n  @Field()\n  authorId: number\n\n  @Field(type => Author)\n  author: Author\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["the other hand, ",(0,a.jsx)(t.code,{children:"TypeORM"})," uses regular classes and decorators for a database model. This means a class file can contain decorators for ",(0,a.jsx)(t.code,{children:"TypeORM"})," as well as for ",(0,a.jsx)(t.code,{children:"type-graphql"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-graphql",children:"@ObjectType()\n@Entity()\nexport class Book {\n\n  @Field(type => Int)\n  @PrimaryGeneratedColumn()\n  id: number\n\n  @Field()\n  @Column()\n  title: string\n\n  @Column()\n  fieldNotExposingToTheGraph: string\n\n  @Field(type => [Author])\n  @ManyToMany(() => Author, author => author.books, {\n    onDelete: 'CASCADE'\n  })\n  @JoinTable()\n  authors: Author[]\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"(2) Easier to handle many to many relationship"}),"\n",(0,a.jsxs)(t.p,{children:["I think it is easier to handle many to many relationships with ",(0,a.jsx)(t.code,{children:"TypeORM"}),". We can just add @ManyToMany decorator. See my ",(0,a.jsx)(t.code,{children:"TypeORM"})," project example where I handle many to many relationship. It\u2019s not easy with ",(0,a.jsx)(t.code,{children:"Prisma"})," as far as I understand. Actually, ",(0,a.jsx)(t.code,{children:"TypeORM"})," is more intuitive when it comes to defining relationships in my opinion."]}),"\n",(0,a.jsx)(t.p,{children:"(3) More flexible"}),"\n",(0,a.jsx)(t.p,{children:"TypeORM is more flexible and provides more options. It supports both Active Record and DataMapper patterns (see doc here). It has its own query APIs like find() as well as query builder support. Writing code for database queries is more flexible with TypeORM. It\u2019s similar to Hibernate (for JAVA), Doctrine ORM (for PHP) and Entity Framework (for .NET). If you have worked with one of those, the transition is easier."}),"\n",(0,a.jsx)(t.p,{children:"In conclusion, if you are not really sure which one to use for your GraphQL API project, I recommend TypeORM. Having said that, both tools are very similar and Prisma is also very easy to use. If you want to investigate more, check out the projects that use Prisma and TypeORM and you can make up your own mind."}),"\n",(0,a.jsx)(t.h2,{id:"examples-projects",children:"Examples Projects"}),"\n",(0,a.jsx)(t.p,{children:"If you're interested in what they are like..."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://github.com/mydatahack/javascript-projects/tree/master/TypeORM-MySQL-Ts",children:"GraphQL with TypeORM, TypeScript and MySQL"}),"\n",(0,a.jsx)(t.a,{href:"https://github.com/mydatahack/javascript-projects/tree/master/Prisma-MySQL-Ts",children:"GraphQL with Prisma, TypeScript and MySQL"})]}),"\n",(0,a.jsx)(t.p,{children:"(2021-05-20)"})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var a=n(96540);const o={},r=a.createContext(o);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);
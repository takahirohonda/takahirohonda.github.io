"use strict";(self.webpackChunkmydatahack_blog_site=self.webpackChunkmydatahack_blog_site||[]).push([[388],{70161:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>p,toc:()=>o});var s=n(74848),i=n(28453);const r={sidebar_position:1},a="TypeScript: type aliases to check type equality",p={id:"Web/Frontend/type-equality-check-type-aliases",title:"TypeScript: type aliases to check type equality",description:"This post is to analyse how the type equality check by using type aliases proposed by Matt Pocock in his twitter post.",source:"@site/docs/Web/Frontend/1.type-equality-check-type-aliases.md",sourceDirName:"Web/Frontend",slug:"/Web/Frontend/type-equality-check-type-aliases",permalink:"/docs/Web/Frontend/type-equality-check-type-aliases",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Frontend",permalink:"/docs/category/frontend"},next:{title:"Fixing it.only type error in Jest",permalink:"/docs/Web/Frontend/it-only-type-error-jest"}},c={},o=[];function l(e){const t={code:"code",h1:"h1",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"typescript-type-aliases-to-check-type-equality",children:"TypeScript: type aliases to check type equality"}),"\n",(0,s.jsx)(t.p,{children:"This post is to analyse how the type equality check by using type aliases proposed by Matt Pocock in his twitter post."}),"\n",(0,s.jsx)(t.p,{children:"These type aliases allow us to elegantly express type equality checks in unit tests. All we need to do is to pass the output and expected types in a simple syntax."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"({} as Expect>);"})}),"\n",(0,s.jsx)(t.p,{children:"Here are the type aliases."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"export type Expect = T;\n\nexport type Equal = (() => T extends A ? 1 : 2) extends <T>() => T extends B\n  ? 1\n  : 2\n  ? true\n  : false;\n\nexport type NotEqual = Equal extends true ? false : true;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The expression ",(0,s.jsx)(t.code,{children:"export type Equal = (() => T extends A ? 1 : 2) extends () => T extends B ? 1 : 2 ? true : false;"})," defines a type alias called Equal."]}),"\n",(0,s.jsx)(t.p,{children:"The type alias Equal is used to compare two types A and B and determine if they are equal."}),"\n",(0,s.jsxs)(t.p,{children:["The comparison is performed using conditional type inference in TypeScript. The expression ",(0,s.jsx)(t.code,{children:"() => T extends A ? 1 : 2"})," creates a function that checks if a generic type T extends A. If it does, the function returns 1; otherwise, it returns 2."]}),"\n",(0,s.jsxs)(t.p,{children:["Similarly, ",(0,s.jsx)(t.code,{children:"() => T extends B ? 1 : 2"})," creates another function that checks if the same generic type T extends B."]}),"\n",(0,s.jsxs)(t.p,{children:["The overall expression (",(0,s.jsx)(t.code,{children:"() => T extends A ? 1 : 2) extends () => T extends B ? 1 : 2 ? true : false"})," compares the two functions. If the function checking A extends the function checking B, it means that type A and type B are equal. In this case, the expression evaluates to true; otherwise, it evaluates to false."]}),"\n",(0,s.jsx)(t.p,{children:"Therefore, the Equal type is true if types A and B are equal, and false otherwise."}),"\n",(0,s.jsx)(t.p,{children:"Here is the unit test example asserting different types."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { type Equal, type Expect } from './testHelpers';\n\ndescribe('testHelpers', () => {\n  describe('Equal, Expect type alias', () => {\n    it('should assert never type', () => {\n      type Value = never;\n      type Expected = never;\n      ({} as Expect>);\n    });\n\n    it('should assert unknown type', () => {\n      type Value = unknown;\n      type Expected = unknown;\n      ({} as Expect>);\n    });\n\n    it('should assert literal types', () => {\n      type Value = 'hello';\n      type Expected = 'hello';\n      ({} as Expect>);\n    });\n\n    it('should assert union types', () => {\n      type Value = string | number;\n      type Expected = string | number;\n      ({} as Expect>);\n    });\n\n    it('should assert intersection types', () => {\n      type Value = { a: number } & { b: string };\n      type Expected = { a: number } & { b: string };\n      ({} as Expect>);\n    });\n\n    it('should assert tuple types', () => {\n      type Value = [number, string];\n      type Expected = [number, string];\n      ({} as Expect>);\n    });\n\n    it('should assert function types', () => {\n      type Value = (x: number) => string;\n      type Expected = (x: number) => string;\n      ({} as Expect>);\n    });\n\n    it('should assert array types', () => {\n      type Value = number[];\n      type Expected = number[];\n      ({} as Expect>);\n    });\n\n    it('should assert object types', () => {\n      type Value = { a: number; b: string };\n      type Expected = { a: number; b: string };\n      ({} as Expect>);\n    });\n  });\n});\n"})}),"\n",(0,s.jsx)(t.p,{children:"(2023-06-06)"})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>p});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function p(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);
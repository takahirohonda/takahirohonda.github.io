"use strict";(self.webpackChunkmydatahack_blog_site=self.webpackChunkmydatahack_blog_site||[]).push([[135],{27393:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=t(74848),s=t(28453);const o={sidebar_position:3},r="Implementing Dependency Injection in ASP.NET Core",a={id:"Web/DotNet/dependency-injection",title:"Implementing Dependency Injection in ASP.NET Core",description:"Dependency Injection is the heart of clean architecture for an ASP.NET Core application. It is supported out of the box when you create an ASP.NET Core application with the Microsoft.Extensions.DependencyInjection module. In the start up file, you can add the mapping between interface and actual implementation. IServiceCollection has methods to add services to the container with Lifetime. When the app starts up, services are added to the container. When a class is instantiated, concrete classes are to be injected.",source:"@site/docs/Web/DotNet/3.dependency-injection.md",sourceDirName:"Web/DotNet",slug:"/Web/DotNet/dependency-injection",permalink:"/mydatahack-old-blog/docs/Web/DotNet/dependency-injection",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"inter-server-hosting",permalink:"/mydatahack-old-blog/docs/Web/DotNet/inter-server-hosting"},next:{title:"How to Deploy ASP.NET Core Application to Windows with IIS",permalink:"/mydatahack-old-blog/docs/Web/DotNet/deploy-with-iis"}},c={},l=[];function p(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"implementing-dependency-injection-in-aspnet-core",children:"Implementing Dependency Injection in ASP.NET Core"}),"\n",(0,i.jsx)(n.p,{children:"Dependency Injection is the heart of clean architecture for an ASP.NET Core application. It is supported out of the box when you create an ASP.NET Core application with the Microsoft.Extensions.DependencyInjection module. In the start up file, you can add the mapping between interface and actual implementation. IServiceCollection has methods to add services to the container with Lifetime. When the app starts up, services are added to the container. When a class is instantiated, concrete classes are to be injected."}),"\n",(0,i.jsx)(n.p,{children:"This is really all you need to do to support DI in the ASP.NET core app."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public void ConfigureServices(IServiceCollection services)\n{\n    // Add dependencies manually\n    services.AddScoped(typeof(IAppLogger<>), typeof(LoggerAdapter<>));\n    services.AddScoped(typeof(IEfRepository<>), typeof(EfRepository<>));\n    services.AddScoped<IAppsRepository, AppsRepository>();\n    services.AddScoped<IAppReviewRepository, AppReviewRepository>();\n    services.AddScoped<IAppCategoryRespository, AppCategoryRespository>();\n    ...\n\n    services.AddMvc()\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The problem with this approach is that we need to keep adding dependencies as we add more classes and interfaces. What if we have hundreds of dependencies and we need to keep track? This solution becomes unmanageable quickly. It is also annoying to update a dependency in another file whenever we create a new class."}),"\n",(0,i.jsx)(n.p,{children:"New Solutions"}),"\n",(0,i.jsx)(n.p,{children:"So, here is my solution that I borrowed from Sitecore\u2019s Habitat example. I have written a blog about DI in Sitecore where I mentions this example. As it is using the out-of-the-box Microsoft Dependency Injection module, it can be used for ASP.NET Core applications."}),"\n",(0,i.jsx)(n.p,{children:"The idea is very simple. We extend IServiceCollection to have methods to read class attributes with service type and lifetime information by reflection. Then, dependencies get registered when the app starts up. In this way, we can manage dependencies in the same class file by adding attributes instead of keeping in the separate files."}),"\n",(0,i.jsx)(n.p,{children:"See what I mean below."}),"\n",(0,i.jsx)(n.p,{children:"We can add attributes with service type and lifetime. See my blog on DI lifetime here for further information."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-C#",children:"// Add attribute\n// Interface for the class & Lifetime\n// (1) Scoped\n[Service(typeof(IAppsRepository), Lifetime.Scoped)]\npublic class AppsRepository : IAppsRepository\n{\n  ...\n}\n\n// (2) Transient\n[Service(typeof(IAppsRepository), Lifetime.Transient)]\npublic class AppsRepository : IAppsRepository\n{\n  ...\n}\n\n// (3) Singleton\n[Service(typeof(IAppsRepository), Lifetime.Singleton)]\npublic class AppsRepository : IAppsRepository\n{\n  ...\n}\n\n// (4) Generics\n[Service(typeof(IAppLogger<>), Lifetime.Scoped)]\npublic class LoggerAdapter<T> : IAppLogger<T>\n{\n  ...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the startup, we can add a new method with the wildcard keyword for the dll. With the extended method, it will look for the service attribute in all the classes including the word passed as an argument. Look how manageable the Startup.cs file becomes!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-C#",children:'public void ConfigureServices(IServiceCollection services)\n{\n    // Add dependencies with extension methods\n    services.AddClassesWithServiceAttribute("ApplicationCore");\n    services.AddClassesWithServiceAttribute("Infrastructure");\n    services.AddClassesWithServiceAttribute("Web");\n\n    // AddMvc for controllers\n    services.AddMvc()\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Implementing IServiceCollection Extensions"}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s dive deep into the actual implementation. As I mentioned above, I adapted this solution from Sitecore\u2019s Habitat example. There are a bit of changes. If you copy & paste this solution, it will work for ASP.NET Core apps. One of the biggest difference is that we do not need to register controllers explicitly as we can use AddMvc() to register controllers."}),"\n",(0,i.jsx)(n.p,{children:"If your solution has only one project, you can create a folder called Extensions and add them in there. If you are using an Onion architecture like this example, I would put it in the Application Core as it needs to be referenced by other projects. It is however an anti-pattern as this extension is not really a business logic."}),"\n",(0,i.jsx)(n.p,{children:"So, once you have the Extension folder, you need to create two files. One is for the attribute model and the other is the actual extensions."}),"\n",(0,i.jsx)(n.p,{children:"ServiceAttribute.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-C#",children:"using System;\n\nnamespace ApplicationCore.Extensions\n{\n    public enum Lifetime\n    {\n        Transient,\n        Singleton,\n        Scoped\n    }\n\n    [AttributeUsage(AttributeTargets.Class, Inherited = false)]\n    public class ServiceAttribute : Attribute\n    {\n        public Lifetime Lifetime { get; set; }\n        public Type ServiceType { get; set; }\n\n        public ServiceAttribute(Type serviceType, Lifetime lifetime)\n        {\n            this.ServiceType = serviceType;\n            this.Lifetime = lifetime;\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"SearviceCollectionExtenstions.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-C#",children:'/*\n * Based on Habitat\n * https://github.com/Sitecore/Habitat/tree/master/src/Foundation/DependencyInjection/code\n */\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text.RegularExpressions;\nusing System.IO;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace ApplicationCore.Extensions\n{\n    public static class ServiceCollectionExtensions\n    {\n\n        public static void AddClassesWithServiceAttribute(this IServiceCollection serviceCollection,\n            params string[] assemblyFilters)\n        {\n            var assemblies = GetAssemblies(assemblyFilters);\n            serviceCollection.AddClassesWithServiceAttribute(assemblies);\n        }\n\n        private static void AddClassesWithServiceAttribute(this IServiceCollection serviceCollection,\n            params Assembly[] assemblies)\n        {\n            var typesWithAttributes = assemblies\n                .Where(assembly => !assembly.IsDynamic)\n                .SelectMany(GetExportedTypes)\n                .Where(type => !type.IsAbstract)\n                .Select(type => new\n                {\n                    type.GetCustomAttribute<ServiceAttribute>()?.Lifetime,\n                    ServiceType = type,\n                    ImplementationType = type.GetCustomAttribute<ServiceAttribute>()?.ServiceType\n                })\n                .Where(t => t.Lifetime != null);\n\n            foreach (var type in typesWithAttributes)\n            {\n                if (type.ImplementationType == null)\n                {\n                    serviceCollection.Add(type.ServiceType, type.Lifetime.Value);\n                }\n                else\n                {\n                    serviceCollection.Add(type.ImplementationType, type.ServiceType, type.Lifetime.Value);\n                }\n            }\n        }\n\n        private static void Add(this IServiceCollection serviceCollection, Type type, Lifetime lifetime)\n        {\n            switch (lifetime)\n            {\n                case Lifetime.Scoped:\n                    serviceCollection.AddScoped(type);\n                    break;\n                case Lifetime.Singleton:\n                    serviceCollection.AddSingleton(type);\n                    break;\n                case Lifetime.Transient:\n                    serviceCollection.AddTransient(type);\n                    break;\n\n                default:\n                    throw new ArgumentOutOfRangeException(nameof(lifetime), lifetime, null);\n            }\n        }\n\n        private static void Add(this IServiceCollection serviceCollection,\n        Type serviceType,\n        Type implementationType,\n        Lifetime lifetime)\n        {\n            switch (lifetime)\n            {\n                case Lifetime.Scoped:\n                    serviceCollection.AddScoped(serviceType, implementationType);\n                    break;\n                case Lifetime.Singleton:\n                    serviceCollection.AddSingleton(serviceType, implementationType);\n                    break;\n                case Lifetime.Transient:\n                    serviceCollection.AddTransient(serviceType, implementationType);\n                    break;\n                default:\n                    throw new ArgumentOutOfRangeException(nameof(lifetime), lifetime, null);\n            }\n        }\n\n        private static Assembly[] GetAssemblies(IEnumerable<string> assemblyFilters)\n        {\n            var assemblies = new List<Assembly>();\n\n            foreach (var assemblyFilter in assemblyFilters)\n            {\n                assemblies.AddRange(AppDomain.CurrentDomain.GetAssemblies()\n                    .Where(assembly => IsWildcardMatch(assembly.GetName().Name, assemblyFilter))\n                    .ToArray());\n            }\n\n            return assemblies.ToArray();\n        }\n\n        private static IEnumerable<Type> GetTypesImplementing(Type implementsType,\n        IEnumerable<Assembly> assemblies,\n        params string[] classFilter)\n        {\n            var types = GetTypesImplementing(implementsType, assemblies.ToArray());\n\n            if (classFilter != null && classFilter.Any())\n            {\n                types = types.Where(type => classFilter.Any(filter => IsWildcardMatch(type.FullName, filter)));\n            }\n\n            return types;\n        }\n\n        private static IEnumerable<Type> GetTypesImplementing(Type implementsType, params Assembly[] assemblies)\n        {\n            if (assemblies == null || assemblies.Length == 0)\n            {\n                return new Type[0];\n            }\n\n            var targetType = implementsType;\n\n            return assemblies\n                .Where(assembly => !assembly.IsDynamic)\n                .SelectMany(GetExportedTypes)\n                .Where(type => !type.IsAbstract\n                  && !type.IsGenericTypeDefinition\n                  && targetType.IsAssignableFrom(type))\n                .ToArray();\n        }\n\n        private static IEnumerable<Type> GetExportedTypes(Assembly assembly)\n        {\n            try\n            {\n                return assembly.GetExportedTypes();\n            }\n            catch (NotSupportedException)\n            {\n                // A type load exception would typically happen on an Anonymously Hosted DynamicMethods\n                // Assembly and it would be safe to skip this exception.\n                return Type.EmptyTypes;\n            }\n            catch (FileLoadException)\n            {\n                // The assembly points to a not found assembly - ignore and continue\n                return Type.EmptyTypes;\n            }\n            catch (ReflectionTypeLoadException ex)\n            {\n                // Return the types that could be loaded. Types can contain null values.\n                return ex.Types.Where(type => type != null);\n            }\n            catch (Exception ex)\n            {\n                // Throw a more descriptive message containing the name of the assembly.\n                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture,\n                    "Unable to load types from assembly {0}. {1}", assembly.FullName, ex.Message), ex);\n            }\n        }\n\n        private static bool IsWildcardMatch(string assemblyName, string wildcardStringToGetAssembly)\n        {\n            return assemblyName == wildcardStringToGetAssembly\n                   || Regex.IsMatch(assemblyName,"^" + Regex.Escape(wildcardStringToGetAssembly)\n                       .Replace("\\\\*", ".*") + "$", RegexOptions.IgnoreCase);\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Once you add these methods, you can start using attributes to register dependencies in your ASP.NET Core application."}),"\n",(0,i.jsx)(n.p,{children:"Sweet!"}),"\n",(0,i.jsx)(n.p,{children:"Wait, there is more\u2026 What about writing unit tests on this extension method?"}),"\n",(0,i.jsx)(n.p,{children:"Unit Tests"}),"\n",(0,i.jsx)(n.p,{children:"First, we create mock classes and interfaces in the test project."}),"\n",(0,i.jsx)(n.p,{children:"MockClassForExtensionsTests.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-C#",children:"using ApplicationCore.Extensions;\n\nnamespace UnitTests.ApplicationCore.Extensions\n{\n    [Service(typeof(IMockClassForExtensionsTestsA), Lifetime.Transient)]\n    public class MockClassForExtensionsTestsA : IMockClassForExtensionsTestsA\n    { }\n\n    public interface IMockClassForExtensionsTestsA\n    { }\n\n    [Service(typeof(IMockClassForExtensionsTestsB), Lifetime.Scoped)]\n    public class MockClassForExtensionsTestsB : IMockClassForExtensionsTestsB\n    { }\n\n    public interface IMockClassForExtensionsTestsB\n    { }\n\n    [Service(typeof(IMockClassForExtensionsTestsC), Lifetime.Transient)]\n    public class MockClassForExtensionsTestsC : IMockClassForExtensionsTestsC\n    { }\n\n    public interface IMockClassForExtensionsTestsC\n    { }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then, we can instantiate ServiceCollection and call the newly created extension method, AddClassesWithServiceAttribute and target dll in the unit test project. This will read attributes from the mock classes created above from the dll."}),"\n",(0,i.jsx)(n.p,{children:"ServiceCollectionExtensionsTest.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-C#",children:'using Xunit;\nusing FluentAssertions;\nusing Microsoft.Extensions.DependencyInjection;\nusing ApplicationCore.Extensions;\n\nnamespace UnitTests.ApplicationCore.Extensions\n{\n    public class ServiceCollectionExtensionsTest\n    {\n        private readonly IServiceCollection _serviceCollection;\n\n        public ServiceCollectionExtensionsTest()\n        {\n            _serviceCollection = new ServiceCollection();\n        }\n\n        [Fact]\n        public void AddClassesWithServiceAttribute_Should_Register_Correctly()\n        {\n            // Act\n            _serviceCollection.AddClassesWithServiceAttribute("UnitTests");\n\n            // Assert\n            _serviceCollection.Count.Should().Be(3);\n\n            foreach (var i in _serviceCollection)\n            {\n                // It works with getting type. For ServiceType, it can get type of. Alternatively,\n                // Alternatively we can do i.ServiceType.Name = "IMockClassForExtensionsTestsA"\n                if (i.ServiceType == typeof(IMockClassForExtensionsTestsA))\n                {\n                    i.ImplementationType.Name.Should().Be("MockClassForExtensionsTestsA");\n                    i.Lifetime.Equals(Lifetime.Transient);\n\n                    // These don\'t work... type comes up as System.Runtime.Type\n                    //Assert.IsType(i.ImplementationType, typeof(MockClassForExtensionsTestsA));\n                    //i.ImplementationType.Name.Should().BeOfType<MockClassForExtensionsTestsA>();\n                }\n\n                if (i.ServiceType == typeof(IMockClassForExtensionsTestsB))\n                {\n                    i.ImplementationType.Name.Should().Be("MockClassForExtensionsTestsB");\n                    i.Lifetime.Equals(Lifetime.Scoped);\n                }\n\n                if (i.ServiceType == typeof(IMockClassForExtensionsTestsC))\n                {\n                    i.ImplementationType.Name.Should().Be("MockClassForExtensionsTestsC");\n                    i.Lifetime.Equals(Lifetime.Singleton);\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This is it for now. It is your turn to try this out. Let us know how you go!"}),"\n",(0,i.jsx)(n.p,{children:"(2019-12-16)"})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);